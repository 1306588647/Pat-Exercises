#include<stdio.h>
int main()
{
	int a[101] = { 0 };
	int in, n,i,k=0;
	scanf("%d",&n);
	int count = n;
	for (i = 0; i < n; i++)
	{
		scanf("%d",&in);
		a[in] = 1;
	}
	for ( i = 1; i <=100 ; i++)
	{
		if (a[i] == 1)
		{
			int j = i;
			while (j != 1)
			{
				if (j % 2 == 0)j = j / 2;
				else j = (j * 3 + 1) / 2;
				if (j <= 100 && a[j] == 1)
				{
					a[j] = 0;
					count--;
					if(j<i)break;			//这行代码的作用就是当i为偶数且j=i/2时，不必再往后验证j之后的情况
				}
			}
		}
	}
	for ( i = 100; i >=1 ; i--)
	{
		if (a[i] == 1)
		{
			printf("%d%c",i,--count? ' ':'\n');
		}
	}
}




/*
总结：  
 （1）该题难度相对于1001难度较大，其中运用了一种编程思想，类似于桶排序的编程方法，就是利用数组下标来存储数据，
当数据的值和数组下标的值相同时，将该下标对应的数组值改为1（数组初始化都为0）这样的话，值为1的数组下标的值就是存储数据的值。

（2）然后该题的解决方法就是每一个值都进行卡拉兹的运算，运算出来后就将该值对应的数组改为0，
直到进行完，最后数组为1下标就是最后输出的答案。

*/